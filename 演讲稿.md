好的，没问题。一份优秀的答辩稿是成功答辩的关键，它能帮您把PPT中的所有亮点串联成一个引人入胜的技术故事。

我将严格按照我们最终确定的PPT结构，为您撰写一份技术风、GitHub风的答辩稿。这份稿子语言精炼、逻辑清晰、重点突出，您可以直接使用，也可以根据自己的语言习惯稍作调整。

---

### 高性能轻量级Web服务器 | 答辩演示稿

**(开场)**

`[面向评委，沉稳自信地开始]`

各位老师好，我是谭宇轩。今天我为大家汇报的项目是——**基于epoll的高性能轻量级Web服务器**。

---

**(第1页：封面)**

`[停顿1-2秒，让大家看清标题]`

---

**(第2页：章节页 - 项目概述)**

`[点击翻页]`

首先，我们来看**第一部分：项目概述**。

---

**(第3页：项目定位)**

`[手势或鼠标指向PPT中央]`

在开始介绍具体功能之前，我想先明确我们这个项目的核心定位。我们着手开发的，并不仅仅是一个单一的Web应用，而是一个更具通用性的、轻量级的**Web服务器『框架』**。

它的核心价值，是为上层业务提供稳定可靠的HTTP处理核心，把开发者从复杂的底层I/O和协议解析中解放出来。

`[语速稍放缓，强调]`

我们追求的设计哲学，是给予上层开发者最大的**自由度**去实现他们的自定义逻辑。

为了完整地演示这个框架的能力，我们基于它，构建了一个**示例后端应用**，也就是`user_backend`，并配套了前端界面。

---

**(第4页：整体架构)**

`[用鼠标或手势依次指向图中的三个部分：浏览器 -> 后端应用 -> 核心库]`

这张图展示了项目的整体架构。

最左侧是用户的浏览器。当用户发起HTTP请求，首先到达的是我们的**用户后端应用**。这个应用，正如大家所见，包含了`main.c`作为程序入口，以及`api.c`来处理具体的业务逻辑。

`[重点指向后端应用与核心库之间的箭头]`

而这个用户后端应用，完全建立在右侧的**核心服务器库**之上。`main.c`通过调用框架的接口来注册路由、启动服务；而当请求到达时，框架的HTTP处理核心，则会**回调**`api.c`中相应的业务逻辑函数。

这种“调用与回调”的模式，清晰地体现了框架与应用的分离。

---

**(第5页：章节页 - 核心库设计)**

`[点击翻页]`

接下来，我们进入**第二部分：核心库设计与实现**。

---

**(第6页：核心库内部依赖)**

`[指向图表]`

这张图进一步剖析了我们核心库`libwebserver.a`的内部依赖关系。

`[指向顶部的蓝色方框]`

最顶上蓝色的部分，是我们刚刚提到的用户代码。`main.c`作为入口，它会调用我们的**路由模块**（`router.c`）来注册URL和处理函数的映射，然后调用**服务核心**（`server.c`）来启动整个服务器。

`[指向下方的调用链]`

当请求到来时，`server.c`会根据请求类型，决定是交由`http.c`处理**静态资源**，还是交由`router.c`进行**动态API分发**。`router.c`找到匹配的规则后，就会回调到用户`api.c`中相应的业务函数。

`[指向最底部的公共依赖]`

最下方的`logger`、`config`和`utils`作为公共依赖，为所有上层模块提供了日志、配置和工具支持。整个设计职责清晰，高内聚，低耦合。

---

**(第7页：目录结构)**

`[快速过，不需详细讲解]`

为了支撑这个架构，我们设计了规范的目录结构。大家可以看到，`Web_Server_for_Learning`目录存放的是可以被编译成静态库的核心代码，而`user_backend`则包含了所有与业务相关的应用代码和静态资源。

---

**(第8页：章节页 - 功能点展示)**

`[点击翻-页]`

了解了整体设计后，我们进入**第三部分：功能点展示**。

---

**(第9页：功能点展示顺序)**

我们将按照从基础到核心的顺序，结合现场演示，逐一介绍服务器的核心功能。

`[此处准备切换到终端和浏览器窗口]`

---

**(第10-14页：静态服务 & 错误响应)**

`[开始讲解]`

首先是任何Web服务器都必须具备的基础功能：**静态服务**。我们的服务器能够提供HTML页面、图片、CSS等多种静态资源，并且能对不存在的资源返回规范的`404`错误页面。

`[切换到浏览器，现场演示]`

**现在，我们来访问一下博客首页。**

`[打开index.html]`

大家可以看到，页面正常加载，并且图片、CSS样式都已应用。这证明服务器正确处理了多个并发的静态资源请求。

**接下来，我们尝试访问一个不存在的地址。**

`[在浏览器输入一个无效URL]`

服务器正确地返回了我们预设的`404`页面。

`[切回PPT，到核心逻辑页]`

这个功能的实现主要在`http.c`的`handleStaticRequest`函数中。它的逻辑非常直接：安全地拼接文件路径，尝试用`open`打开。如果失败，就构建并发送404响应；如果成功，则根据文件后缀名，像`.css`或`.jpg`，获取正确的MIME类型，然后构建`200 OK`响应头，最后循环读取并发送文件内容。

---

**(第15-18页：配置与日志系统)**

`[开始讲解]`

接下来是支撑整个项目健壮性的**配置与日志系统**。服务器的行为由外部的`server.conf`驱动，同时配备了系统日志和访问日志，分离了系统状态与用户访问记录。

`[现场演示]`

**我们来看一下配置文件和日志文件。**

`[打开server.conf，指向LogLevel=DEBUG。再打开log/目录，展示access.log和system.log]`

大家可以看到，我们配置了`DEBUG`级别的日志。`system.log`里详细记录了服务器的启动过程，而`access.log`则记录了我们刚才的每一次访问。

`[切回PPT，到日志缓冲亮点页]`

这里我想特别介绍我们在日志系统上的一个**亮点设计：启动时日志缓冲**。

在配置文件加载完成前，日志系统并不知道该以什么级别、输出到哪里。这是一个典型的“鸡生蛋”问题。我们的解决方案是：在日志系统未完全初始化时，所有日志调用都会被**暂存到内存缓冲区**。当`logger_init`根据配置完成初始化后，它会立即“回放”缓冲区里的所有日志，确保任何阶段的日志都不会丢失，并且最终都按用户的配置进行输出。

---

**(第19-21页：动态服务 GET/POST)**

`[开始讲解]`

看完了基础功能，我们来看动态服务。我们通过一个“学生数据查询”功能，来演示服务器如何处理`GET`和`POST`请求。

`[现场演示]`

**请看这个查询页面。**

`[打开search.html]`

我们先用`GET`方式查询，关键词会出现在URL中。

`[输入查询条件，点击GET查询]`

成功返回了结果。现在我们用`POST`方式，参数将通过请求体发送。

`[输入查询条件，点击POST查询]`

同样成功了。

`[切回PPT，到核心逻辑页]`

这个功能的实现，首先是在`main.c`里，我们将`/api/search`这个路径，同时注册给了`GET`和`POST`方法，并绑定到不同的处理函数。在`api.c`中，`GET`方法从请求的查询字符串中解析参数，而`POST`方法则从请求体中解析，从而实现了对不同HTTP方法的支持。

---

**(第22-25页：安全认证)**

`[开始讲解]`

作为框架，安全认证是必不可少的一环。我们实现了基于JWT的完整用户流程：**注册、登录、和Token鉴权**。

`[现场演示]`

**首先，如果我未登录，直接访问个人中心...**

`[打开me.html，页面自动跳转到login.html]`

会被自动重定向到登录页。

**我们先注册一个新用户...** `[操作注册]` **...注册成功。**

**现在用新用户登录...** `[操作登录]` **...登录成功，页面自动跳转，并成功获取到了我的用户信息！**

`[切回PPT，到核心逻辑页]`

这背后，是`api.c`中的注册逻辑负责查重并写入CSV文件；登录逻辑则负责校验凭据，并调用`auth.c`中的`generate_token_for_user`函数生成JWT。当访问受保护资源时，`authenticate_request`函数会验证请求头中的Token，验证通过后，才能继续处理业务。

---

**(第26-29页：核心服务逻辑 Epoll)**

`[进入技术核心部分，语速沉稳，充满自信]`

最后，我们来揭示所有功能背后，实现高性能的基石：**核心服务逻辑**。

我们采用的是Linux平台下最高效的I/O多路复用技术`epoll`，并结合非阻塞I/O，构建了经典的**单线程Reactor并发模型**。它的核心优势在于能用单线程管理海量连接，并且由事件驱动，极大提升了资源利用率。

`[翻到主事件循环代码页]`

服务器的心脏，就是`server.c`中的这个`while`主循环。它阻塞在`epoll_wait`，统一处理四种事件：**新连接到达、socket可读、socket可写、以及连接关闭**。

`[翻到流程图页，这是讲解的重点]`

这张流程图更直观地展示了整个过程。
主循环等待`epoll_wait`返回。
- 如果是**新连接**，就`accept`它，并把它注册到epoll中监听**读事件**。
- 如果是**socket可读**，就调用`handleConnection`，在这里面，我们会循环`read`数据到缓冲区，然后调用我们的**增量解析器**进行解析。如果解析出一个完整的请求，就分发给业务逻辑，并准备好响应数据，然后修改epoll，监听**写事件**。
- 如果是**socket可写**，就调用`handleWrite`，将响应数据`write`回客户端。

`[翻到增量解析页]`

在刚才的读事件处理中，有一个关键的算法，就是**增量式HTTP解析**。因为TCP是字节流，存在粘包、半包问题。我们的解决方案是基于状态机：
`[指着状态机流程]`
从**解析请求行** -> **解析请求头** -> **解析请求体** -> **解析完成**。
每次只读一部分数据，然后从上次结束的位置继续解析。如果数据不够，就保留当前状态，等待下一次数据到来。这个设计，也是我们能通过超长消息测试的关键。

---

**(第30页：章节页 - 总结与展望)**

`[点击翻页]`

最后，是**第四部分：总结与展望**。

---

**(第31页：项目总结)**

`[自信地总结]`

总结一下，本次项目：
- 在**架构**上，我们成功实现了库与应用分离的高内聚、低耦合架构，并采用了成熟的Reactor模型。
- 在**功能**上，完整实现了静态、动态、安全认证、配置、日志等核心功能。
- 在**技术**上，我们攻克了基于epoll的非阻塞I/O编程，并设计了健壮的增量式解析器和巧妙的日志缓冲机制等技术难点。

---

**(第32页：不足与展望)**

`[谦虚且有远见地提出不足]`

当然，项目还有一些可以完善和展望的地方。比如API的封装可以更优雅，可以引入线程池来处理CPU密集型业务，未来还可以扩展对HTTPS和HTTP Keep-Alive的支持。

---

**(第33页：感谢页)**

我的汇报到此结束。感谢各位老师的聆听，欢迎提问。

`[保持微笑，准备回答问题]`