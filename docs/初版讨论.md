好的，非常感谢您提供如此清晰、具体的要求！现在我完全明白您的意图了。我们不做任何假设，完全围绕您的思路和老师的要求来共同设计一份完美的答辩PPT方案。

8-10分钟的时间非常紧凑，这意味着每一页PPT都必须直击要点，每一分钟的讲述都要有价值。您提出的“先整体架构，再功能细节”的思路非常专业，完全符合一个优秀技术报告的叙事逻辑。

我们这就开始商讨。

---

### PPT设计方案与内容大纲 (讨论稿)

**核心设计思想：** 以“**我们开发了一个Web服务器『框架』**”为故事主线，从顶层设计哲学讲起，层层深入到核心技术实现，最后通过一系列功能点展示来印证框架的能力与设计的完备性。

**整体流程：**
**引言 (约1.5分钟)** -> **核心设计 (约2.5分钟)** -> **功能巡礼 (约4分钟)** -> **总结 (约1分钟)**

---

#### 第一部分：引言与项目定位 (幻灯片 1-3)

1.  **第1页：封面**
    *   **标题**：基于`epoll`的高性能轻量级Web服务器
    *   **副标题**：设计与实现
    *   **信息**：汇报人、日期等。

2.  **第2页：项目概述：一个框架，而非应用**
    *   **核心思想**：开宗明明义，阐述您对项目的定位。
        *   “我们着手开发的并非一个单一的Web应用，而是一个**轻量级、可嵌入的Web服务器『框架』**。”
        *   “它为上层业务提供了稳定可靠的HTTP处理核心，同时给予开发者最大的**自由度**去实现自定义逻辑。”
        *   “为方便本次答辩展示，我们基于此框架构建了一个**示例后端应用** (`user_backend`) 和配套的前端界面，用以演示框架的核心能力。”

3.  **第3页：项目整体架构图**
    *   **目标**：直观展示“框架”、“用户后端”、“前端”三者之间的关系。
    *   **内容**：使用PlantUML绘制一个简洁的、横向的三层/三块架构图。

    ```plantuml
    @startuml
    !theme plain
    left to right direction

    skinparam rectangle {
        roundCorner 20
    }
    skinparam cloud {
        roundCorner 20
    }

    cloud "用户浏览器" as Browser {
        rectangle "前端应用\n(HTML/CSS/JS)" as Frontend
    }

    package "用户后端应用 (user_backend)" <<Node>> {
    rectangle "main.c\n(程序入口)" as Main
    rectangle "api.c\n(用户业务逻辑)" as Api
    }

    package "核心服务器库 (libwebserver.a)" <<Library>> {
        rectangle "接口层\n(startServer, addRoute)" as ServerApi
        rectangle "HTTP处理核心\n(Parser, Router)" as HttpCore
        rectangle "事件循环 (Epoll)" as EpollLoop
        
        ' 强制库内组件垂直排列 (这部分不变)
        ServerApi -[hidden]down-> HttpCore
        HttpCore -[hidden]down-> EpollLoop
    }

    ' 箭头关系 (这部分不变)
    Browser --> Main : HTTP 请求
    Main ..> ServerApi : 调用框架接口
    HttpCore ..> Api : 回调业务逻辑
    Main -> Api : (使用业务逻辑)
    @enduml
    ```

---

#### 第二部分：核心库设计与实现 (幻灯片 4-6)

4.  **第4页：核心库内部架构**
    *   **目标**：剖析`libwebserver.a`的内部结构，让老师看到清晰的设计分层。
    *   **内容**：绘制一个分层架构图，展示从接口层到底层I/O的依赖关系。

    ```plantuml
    @startuml
    !theme plain
    skinparam rectangle {
        roundCorner 10
    }

    package "用户后端应用 (user_backend)" #LightBlue {
        rectangle "main.c\n(程序入口)" as Main
        rectangle "api.c\n(用户业务逻辑)" as Api
    }

    package "核心服务器库 (libwebserver.a)" {
        rectangle "server.c\n(启动 & 事件循环)" as Server
        rectangle "http.c\n(静态请求处理)" as Http
        rectangle "router.c\n(路由分发)" as Router
        rectangle "auth.c\n(认证逻辑)" as Auth
        
        package "公共依赖" {
            rectangle "logger.c" as Logger
            rectangle "config.c" as Config
            rectangle "utils.c" as Utils
        }
    }

    ' 核心调用流程 (自上而下)
    Main --> Server   : 调用 startServer()
    Main --> Router   : 调用 router_add_route()
    Main --> Api      : (使用API函数指针)

    Server --> Http   : (静态请求)
    Server --> Router : 调用 router_find_handler() (动态请求)

    Router --> Api    : (调用用户注册的handler)
    Http   --> Utils
    Api    --> Auth

    ' 隐藏箭头用于布局
    Main -[hidden]down-> Server
    Server -[hidden]down-> Http
    Http -[hidden]down-> Router
    Router -[hidden]down-> Api
    Api -[hidden]down-> Auth
    @enduml
    ```

    *   **讲述要点**：介绍各层职责，强调模块化、高内聚低耦合的设计思想。

5.  **第5页：目录结构展示**
    *   **目标**：快速展示清晰、规范的项目结构。
    *   **内容**：使用Markdown代码块模拟`tree`命令的输出。

    ````markdown
    ```
    .
    ├── Web_Server_for_Learning/  # 核心库
    │   ├── src/                  # 核心库源文件
    │   ├── include/              # 核心库头文件
    │   ├── lib/                  # 生成的 libwebserver.a
    │   └── Makefile
    ├── user_backend/             # 用户示例应用
    │   ├── src/                  # 用户业务逻辑 (api.c, main.c)
    │   ├── include/
    │   ├── www/                  # 前端静态资源
    │   ├── log/                  # 日志文件
    │   └── Makefile
    └── ...
    ```
    ````

6.  **第6页：功能点展示顺序**
    *   **目标**：承上启下，告诉听众接下来将要展示的内容和顺序。
    *   **我建议的顺序及理由**：
        1.  **静态服务 (Index/博客/错误响应)**：这是Web服务器最基础的功能，作为开场最合适。将错误响应捆绑在一起讲，逻辑更连贯。
        2.  **配置与日志系统**：展示这两个“支撑系统”，体现项目的健壮性和可维护性。可以引出“日志缓冲”这个亮点。
        3.  **动态服务 (POST/GET)**：从静态到动态，是功能的自然演进。
        4.  **安全认证**：作为动态服务中最复杂、最完整的示例，展示一个完整的业务闭环。
        5.  **核心服务逻辑 (EPOLL)**：作为技术压轴，在听众看完了所有“功能表象”后，揭秘其背后最高效的“技术核心”，形成技术高潮。
    *   **您觉得这个顺序如何？** 我们可以随时调整。它试图在“逻辑连贯性”和“从易到难”之间取得平衡。

---

#### 第三部分：功能点巡礼 (按上述顺序)

**对于每个功能点，遵循您提出的`概述 -> 逻辑 -> 结果`三段式结构。**

*   **A. 静态服务 & 错误响应**
    *   **概述**: 介绍服务器提供HTML页面、图片、CSS等多种静态资源的能力，并能对不存在的资源返回404页面。
    *   **核心逻辑**: 展示`http.c`中的`handleStaticRequest`函数片段，重点突出：
        1.  路径拼接: `snprintf(path, ..., "%s%s", config->document_root, uri);`
        2.  文件打开: `fileFd = open(path, O_RDONLY);`
        3.  错误处理: `if (fileFd == -1) { ... send 404 ... }`
        4.  MIME类型: `const char* mime_type = getMimeType(path);`
    *   **运行结果**: `[此处提示我插入 index.html 和 404页面的截图]`

*   **B. 配置与日志系统**
    *   **概述**: 介绍外部`server.conf`如何控制服务器行为，以及系统/访问双日志系统的重要性。
    *   **核心逻辑**: **重点展示日志缓冲亮点！**
        *   展示`logger.c`中`log_system`函数的`if (!L.is_initialized)`分支，说明日志是如何被缓存的。
        *   展示`logger_init`函数中调用`flush_and_free_buffer()`的部分，说明缓存是如何在初始化后被“回放”的。
    *   **运行结果**: `[此处提示我插入 server.conf 文件截图 和 log/ 目录下的双日志文件内容截图]`

*   **C. 动态请求处理 (POST/GET)**
    *   **概述**: 介绍服务器如何通过路由系统，将特定路径的GET和POST请求分发给不同的业务逻辑函数。以学生查询功能为例。
    *   **核心逻辑**:
        *   展示`main.c`中的`router_add_route("GET", "/api/search", ...)`和`...("POST", "/api/search", ...)`，体现路由注册。
        *   对比展示`api.c`中两个handler如何分别从`conn->request.raw_query_string`和`conn->request.body`中获取参数。
    *   **运行结果**: `[此处提示我插入 search.html 演示GET和POST查询成功的截图]`

*   **D. 安全认证**
    *   **概述**: 介绍基于JWT的“注册 -> 登录 -> 鉴权”完整用户流程。
    *   **核心逻辑**:
        *   展示`api.c`中`handle_api_register`写入`users.csv`的逻辑。
        *   展示`auth.c`中`authenticate_request`如何从`Authorization`头解析并验证Token的片段。
    *   **运行结果**: `[此处提示我插入 注册成功、登录后跳转、me.html成功显示用户名 的系列截图]`

*   **E. 核心服务逻辑 (EPOLL)**
    *   **概述**: 压轴讲解项目的心脏——基于`epoll`的单线程Reactor模型。
    *   **核心逻辑 (代码)**: 展示`server.c`中的主事件循环 `while(1)`，重点圈出：
        1.  `epoll_wait()`
        2.  处理新连接: `if (events[i].data.fd == listenFd)`
        3.  处理数据读: `else if (events[i].events & EPOLLIN)`
    *   **核心逻辑 (流程图)**: 在新一页展示流程图，我会为您准备PlantUML版本。
    ```plantuml
    @startuml
    !theme plain
    start
    :创建 listenFd 并绑定端口;
    :创建 epollFd;
    :将 listenFd 注册到 epoll;
    
    while (主循环)
      :epoll_wait(阻塞等待事件);
      if (有新连接?) then (yes)
        :accept() 获取 connFd;
        :设置 connFd 为非阻塞;
        :为新连接分配 Connection 结构;
        :将 connFd 注册到 epoll (监听读事件);
      else (no)
        if (socket可读?) then (yes)
          -> YES;
          :调用 handleConnection();
          note right
            1. 循环 read 数据到 conn->read_buf
            2. **调用增量解析器**
            3. 若解析完成，则调用业务逻辑
               (静态 or 动态API)
            4. 准备响应数据到 conn->write_buf
            5. 修改epoll监听为“可写”
          end note
        else (no)
          if (socket可写?) then (yes)
            :调用 handleWrite();
            note right
             1. write(conn->write_buf)
             2. 若全部写完，关闭连接
            end note
          else (no)
            :处理错误/关闭事件;
          endif
        endif
      endif
    endwhile
    
    stop
    @enduml
    ```
    *   **核心逻辑 (增量解析)**: 单独一页，强调这是处理TCP粘包/半包、通过“超长消息”测试的关键。可以文字描述状态机（`PARSE_STATE_REQ_LINE` -> `HEADERS` ...），不必上代码，口述即可。

---

#### 第四部分：总结与展望

*   **总结页**:
    *   **架构**: 成功实现了库/应用分离的高内聚低耦合架构。
    *   **性能**: 基于`epoll`和单线程Reactor模型，保证了高并发处理能力。
    *   **功能**: 完整实现了静态、动态、安全认证、配置、日志等核心功能。
    *   **亮点**: 独创的日志缓冲机制、健壮的增量式HTTP解析器。
*   **展望页**:
    *   **API封装**: 改进接口，降低用户使用复杂度。
    *   **性能**: 引入线程池处理CPU密集型任务。
    *   **功能**: 支持HTTPS和HTTP/1.1 Keep-Alive。
*   **致谢页**: Q&A

---

请您审阅这份详细的设计方案。尤其是**功能点的展示顺序**，以及每个功能点下我提取的**核心逻辑代码**和**图表设计**是否符合您的预期。我们可以基于这个框架进行调整，直到您满意为止，然后我再为您生成完整的`最终PPT.md`文件。